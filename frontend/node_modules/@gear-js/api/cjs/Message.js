'use strict';

var rxjs = require('rxjs');
var message_errors = require('./errors/message.errors.js');
require('@polkadot/util');
require('./utils/generate.js');
require('./utils/prefixes.js');
require('./utils/separator.js');
var validate = require('./utils/validate.js');
require('@polkadot/api');
require('@polkadot/util-crypto');
var createPayload = require('./utils/create-payload.js');
var Transaction = require('./Transaction.js');

class GearMessage extends Transaction.GearTransaction {
    /**
     * ## Send Message
     * @param message
     * @param metaOrHexRegistry Metadata
     * @param typeIndexOrTypeName type index in registry or type name
     * @returns Submitted result
     */
    send({ destination, value, gasLimit, ...args }, metaOrHexRegistry, typeIndexOrTypeName) {
        validate.validateValue(value, this._api);
        validate.validateGasLimit(gasLimit, this._api);
        const payload = createPayload.encodePayload(args.payload, metaOrHexRegistry, 'handle', typeIndexOrTypeName);
        try {
            this.extrinsic = this._api.tx.gear.sendMessage(destination, payload, gasLimit, value || 0);
            return this.extrinsic;
        }
        catch (error) {
            throw new message_errors.SendMessageError(error.message);
        }
    }
    /**
     * Sends reply message
     * @param args Message parameters
     * @param metaOrHexRegistry Metadata
     * @param typeIndexOrTypeName type index in registry or type name
     * @returns Submitted result
     */
    sendReply({ value, gasLimit, replyToId, ...args }, metaOrHexRegistry, typeIndexOrTypeName) {
        validate.validateValue(value, this._api);
        validate.validateGasLimit(gasLimit, this._api);
        const payload = createPayload.encodePayload(args.payload, metaOrHexRegistry, 'reply', typeIndexOrTypeName);
        try {
            this.extrinsic = this._api.tx.gear.sendReply(replyToId, payload, gasLimit, value);
            return this.extrinsic;
        }
        catch (error) {
            throw new message_errors.SendReplyError();
        }
    }
    async sendWithVoucher({ destination, value, gasLimit, payload, account }, metaOrHexRegistry, typeIndexOrTypeName) {
        validate.validateValue(value, this._api);
        validate.validateGasLimit(gasLimit, this._api);
        await validate.validateVoucher(destination, account, this._api);
        const _payload = createPayload.encodePayload(payload, metaOrHexRegistry, 'handle', typeIndexOrTypeName);
        try {
            this.extrinsic = this._api.tx.gear.sendMessageWithVoucher(destination, _payload, gasLimit, value || 0);
            return this.extrinsic;
        }
        catch (error) {
            throw new message_errors.SendMessageError(error.message);
        }
    }
    async sendReplyWithVoucher({ value, gasLimit, replyToId, payload, account }, metaOrHexRegistry, typeIndexOrTypeName) {
        validate.validateValue(value, this._api);
        validate.validateGasLimit(gasLimit, this._api);
        const { source } = await validate.validateMailboxItem(account, replyToId, this._api);
        await validate.validateVoucher(source.toHex(), account, this._api);
        const _payload = createPayload.encodePayload(payload, metaOrHexRegistry, 'reply', typeIndexOrTypeName);
        try {
            this.extrinsic = this._api.tx.gear.sendReplyWithVoucher(replyToId, _payload, gasLimit, value);
            return this.extrinsic;
        }
        catch (error) {
            throw new message_errors.SendReplyError();
        }
    }
    listenToReplies(programId, bufferSize = 5) {
        let unsub;
        const subject = new rxjs.ReplaySubject(bufferSize);
        this._api.gearEvents
            .subscribeToGearEvent('UserMessageSent', ({ data }) => {
            if (data.message.source.eq(programId)) {
                if (data.message.details.isSome) {
                    data.message.details.unwrap().to.toHex();
                    {
                        subject.next([data.message.details.unwrap().to.toHex(), data]);
                    }
                }
            }
        })
            .then((result) => {
            unsub = result;
        });
        return (messageId) => {
            return new Promise((resolve) => {
                subject.subscribe({
                    next: ([id, data]) => {
                        if (id === messageId) {
                            subject.complete();
                            unsub();
                            resolve(data);
                        }
                    },
                });
            });
        };
    }
}

exports.GearMessage = GearMessage;
