import { ReplaySubject } from 'rxjs';
import { SendMessageError, SendReplyError } from './errors/message.errors.js';
import '@polkadot/util';
import './utils/generate.js';
import './utils/prefixes.js';
import './utils/separator.js';
import { validateValue, validateGasLimit, validateVoucher, validateMailboxItem } from './utils/validate.js';
import '@polkadot/api';
import '@polkadot/util-crypto';
import { encodePayload } from './utils/create-payload.js';
import { GearTransaction } from './Transaction.js';

class GearMessage extends GearTransaction {
    /**
     * ## Send Message
     * @param message
     * @param metaOrHexRegistry Metadata
     * @param typeIndexOrTypeName type index in registry or type name
     * @returns Submitted result
     */
    send({ destination, value, gasLimit, ...args }, metaOrHexRegistry, typeIndexOrTypeName) {
        validateValue(value, this._api);
        validateGasLimit(gasLimit, this._api);
        const payload = encodePayload(args.payload, metaOrHexRegistry, 'handle', typeIndexOrTypeName);
        try {
            this.extrinsic = this._api.tx.gear.sendMessage(destination, payload, gasLimit, value || 0);
            return this.extrinsic;
        }
        catch (error) {
            throw new SendMessageError(error.message);
        }
    }
    /**
     * Sends reply message
     * @param args Message parameters
     * @param metaOrHexRegistry Metadata
     * @param typeIndexOrTypeName type index in registry or type name
     * @returns Submitted result
     */
    sendReply({ value, gasLimit, replyToId, ...args }, metaOrHexRegistry, typeIndexOrTypeName) {
        validateValue(value, this._api);
        validateGasLimit(gasLimit, this._api);
        const payload = encodePayload(args.payload, metaOrHexRegistry, 'reply', typeIndexOrTypeName);
        try {
            this.extrinsic = this._api.tx.gear.sendReply(replyToId, payload, gasLimit, value);
            return this.extrinsic;
        }
        catch (error) {
            throw new SendReplyError();
        }
    }
    async sendWithVoucher({ destination, value, gasLimit, payload, account }, metaOrHexRegistry, typeIndexOrTypeName) {
        validateValue(value, this._api);
        validateGasLimit(gasLimit, this._api);
        await validateVoucher(destination, account, this._api);
        const _payload = encodePayload(payload, metaOrHexRegistry, 'handle', typeIndexOrTypeName);
        try {
            this.extrinsic = this._api.tx.gear.sendMessageWithVoucher(destination, _payload, gasLimit, value || 0);
            return this.extrinsic;
        }
        catch (error) {
            throw new SendMessageError(error.message);
        }
    }
    async sendReplyWithVoucher({ value, gasLimit, replyToId, payload, account }, metaOrHexRegistry, typeIndexOrTypeName) {
        validateValue(value, this._api);
        validateGasLimit(gasLimit, this._api);
        const { source } = await validateMailboxItem(account, replyToId, this._api);
        await validateVoucher(source.toHex(), account, this._api);
        const _payload = encodePayload(payload, metaOrHexRegistry, 'reply', typeIndexOrTypeName);
        try {
            this.extrinsic = this._api.tx.gear.sendReplyWithVoucher(replyToId, _payload, gasLimit, value);
            return this.extrinsic;
        }
        catch (error) {
            throw new SendReplyError();
        }
    }
    listenToReplies(programId, bufferSize = 5) {
        let unsub;
        const subject = new ReplaySubject(bufferSize);
        this._api.gearEvents
            .subscribeToGearEvent('UserMessageSent', ({ data }) => {
            if (data.message.source.eq(programId)) {
                if (data.message.details.isSome) {
                    data.message.details.unwrap().to.toHex();
                    {
                        subject.next([data.message.details.unwrap().to.toHex(), data]);
                    }
                }
            }
        })
            .then((result) => {
            unsub = result;
        });
        return (messageId) => {
            return new Promise((resolve) => {
                subject.subscribe({
                    next: ([id, data]) => {
                        if (id === messageId) {
                            subject.complete();
                            unsub();
                            resolve(data);
                        }
                    },
                });
            });
        };
    }
}

export { GearMessage };
