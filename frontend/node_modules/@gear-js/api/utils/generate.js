import { blake2AsHex, blake2AsU8a } from '@polkadot/util-crypto';
import { stringToU8a, u8aToU8a } from '@polkadot/util';
import '@polkadot/types';
import 'assert';
import { CreateType } from '../metadata/create-type.js';
import '../metadata/programMetadata.js';

const VOUCHER_PREFIX = stringToU8a('modlpy/voucher__');
function generateCodeHash(code) {
    return blake2AsHex(u8aToU8a(code), 256);
}
function generateProgramId(codeOrHash, salt) {
    const [code, codeHash] = typeof codeOrHash === 'string' ? [undefined, codeOrHash] : [codeOrHash, undefined];
    const codeHashU8a = codeHash ? u8aToU8a(codeHash) : blake2AsU8a(code, 256);
    const saltU8a = CreateType.create('Vec<u8>', salt).toU8a().slice(1);
    const programStrU8a = new TextEncoder().encode('program');
    const id = Uint8Array.from([...programStrU8a, ...codeHashU8a, ...saltU8a]);
    return blake2AsHex(id, 256);
}
function generateVoucherId(who, program) {
    const whoU8a = u8aToU8a(who);
    const programU8a = u8aToU8a(program);
    const id = Uint8Array.from([...VOUCHER_PREFIX, ...whoU8a, ...programU8a]);
    return blake2AsHex(id, 256);
}

export { generateCodeHash, generateProgramId, generateVoucherId };
