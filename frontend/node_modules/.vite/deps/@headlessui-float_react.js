import {
  te,
  tt
} from "./chunk-OXIN5ZGK.js";
import {
  require_react_dom
} from "./chunk-75JG7GUJ.js";
import {
  require_react
} from "./chunk-DIZYALVS.js";
import {
  __toESM,
  import_process,
  init_shim
} from "./chunk-EVJWUNZB.js";

// node_modules/@headlessui-float/react/dist/headlessui-float.mjs
init_shim();
var import_react3 = __toESM(require_react(), 1);

// node_modules/@floating-ui/react/dist/floating-ui.react.esm.js
init_shim();
var React2 = __toESM(require_react());
var import_react2 = __toESM(require_react());

// node_modules/aria-hidden/dist/es2015/index.js
init_shim();

// node_modules/tabbable/dist/index.esm.js
init_shim();
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");

// node_modules/@floating-ui/react/dist/floating-ui.react.esm.js
var import_react_dom = __toESM(require_react_dom());

// node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js
init_shim();

// node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs
init_shim();

// node_modules/@floating-ui/core/dist/floating-ui.core.browser.mjs
init_shim();
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getLengthFromAxis(axis) {
  return axis === "y" ? "height" : "width";
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "x" : "y";
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  const commonAlign = reference[length] / 2 - floating[length] / 2;
  const side = getSide(placement);
  const isVertical = mainAxis === "x";
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
      continue;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getSideObjectFromPadding(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x,
    y
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var min = Math.min;
var max = Math.max;
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      element,
      padding = 0
    } = options || {};
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements
    } = state;
    if (element == null) {
      return {};
    }
    const paddingObject = getSideObjectFromPadding(padding);
    const coords = {
      x,
      y
    };
    const axis = getMainAxisFromPlacement(placement);
    const length = getLengthFromAxis(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const min3 = paddingObject[minProp];
    const max3 = clientSize - arrowDimensions[length] - paddingObject[maxProp];
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = within(min3, center, max3);
    const shouldAddOffset = getAlignment(placement) != null && center != offset2 && rects.reference[length] / 2 - (center < min3 ? paddingObject[minProp] : paddingObject[maxProp]) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min3 ? min3 - center : max3 - center : 0;
    return {
      [axis]: coords[axis] - alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2
      }
    };
  }
});
var sides = ["top", "right", "bottom", "left"];
var allPlacements = sides.reduce((acc, side) => acc.concat(side, side + "-start", side + "-end"), []);
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement);
  return allowedPlacementsSortedByAlignment.filter((placement) => {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
var autoPlacement = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "autoPlacement",
    options,
    async fn(state) {
      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;
      const {
        rects,
        middlewareData,
        placement,
        platform: platform2,
        elements
      } = state;
      const {
        crossAxis = false,
        alignment,
        allowedPlacements = allPlacements,
        autoAlignment = true,
        ...detectOverflowOptions
      } = options;
      const placements = alignment !== void 0 || allowedPlacements === allPlacements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
      const currentPlacement = placements[currentIndex];
      if (currentPlacement == null) {
        return {};
      }
      const {
        main,
        cross
      } = getAlignmentSides(currentPlacement, rects, await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)));
      if (placement !== currentPlacement) {
        return {
          reset: {
            placement: placements[0]
          }
        };
      }
      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];
      const allOverflows = [...((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || [], {
        placement: currentPlacement,
        overflows: currentOverflows
      }];
      const nextPlacement = placements[currentIndex + 1];
      if (nextPlacement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: nextPlacement
          }
        };
      }
      const placementsSortedByMostSpace = allOverflows.map((d) => {
        const alignment2 = getAlignment(d.placement);
        return [d.placement, alignment2 && crossAxis ? (
          // Check along the mainAxis and main crossAxis side.
          d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0)
        ) : (
          // Check only the mainAxis.
          d.overflows[0]
        ), d.overflows];
      }).sort((a, b) => a[1] - b[1]);
      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter((d) => d[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        getAlignment(d[0]) ? 2 : 3
      ).every((v) => v <= 0));
      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
      if (resetPlacement !== placement) {
        return {
          data: {
            index: currentIndex + 1,
            overflows: allOverflows
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getSideList(side, isStart, rtl) {
  const lr2 = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr2;
      return isStart ? lr2 : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = options;
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const {
          main,
          cross
        } = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[main], overflow[cross]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = options;
      const {
        rects
      } = state;
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, value) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getMainAxisFromPlacement(placement) === "x";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = typeof value === "function" ? value(state) : value;
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(value) {
  if (value === void 0) {
    value = 0;
  }
  return {
    name: "offset",
    options: value,
    async fn(state) {
      const {
        x,
        y
      } = state;
      const diffCoords = await convertValueToCoords(state, value);
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: diffCoords
      };
    }
  };
};
function getCrossAxis(axis) {
  return axis === "x" ? "y" : "x";
}
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = options;
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getSide(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min3 = mainAxisCoord + overflow[minSide];
        const max3 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within(min3, mainAxisCoord, max3);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min3 = crossAxisCoord + overflow[minSide];
        const max3 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within(min3, crossAxisCoord, max3);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  };
};

// node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.mjs
function getWindow(node) {
  var _node$ownerDocument;
  return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isNode(value) {
  return value instanceof getWindow(value).Node;
}
function getNodeName(node) {
  return isNode(node) ? (node.nodeName || "").toLowerCase() : "";
}
var uaString;
function getUAString() {
  if (uaString) {
    return uaString;
  }
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    uaString = uaData.brands.map((item) => item.brand + "/" + item.version).join(" ");
    return uaString;
  }
  return navigator.userAgent;
}
function isHTMLElement(value) {
  return value instanceof getWindow(value).HTMLElement;
}
function isElement(value) {
  return value instanceof getWindow(value).Element;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const isFirefox = /firefox/i.test(getUAString());
  const css = getComputedStyle$1(element);
  const backdropFilter = css.backdropFilter || css.WebkitBackdropFilter;
  return css.transform !== "none" || css.perspective !== "none" || (backdropFilter ? backdropFilter !== "none" : false) || isFirefox && css.willChange === "filter" || isFirefox && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective"].some((value) => css.willChange.includes(value)) || ["paint", "layout", "strict", "content"].some((value) => {
    const contain = css.contain;
    return contain != null ? contain.includes(value) : false;
  });
}
function isClientRectVisualViewportBased() {
  return /^((?!chrome|android).)*safari/i.test(getUAString());
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
var min2 = Math.min;
var max2 = Math.max;
var round = Math.round;
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    fallback: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
var FALLBACK_SCALE = {
  x: 1,
  y: 1
};
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return FALLBACK_SCALE;
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    fallback
  } = getCssDimensions(domElement);
  let x = (fallback ? round(rect.width) : rect.width) / width;
  let y = (fallback ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  var _win$visualViewport, _win$visualViewport2;
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = FALLBACK_SCALE;
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const win = domElement ? getWindow(domElement) : window;
  const addVisualOffsets = isClientRectVisualViewportBased() && isFixedStrategy;
  let x = (clientRect.left + (addVisualOffsets ? ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0 : 0)) / scale.x;
  let y = (clientRect.top + (addVisualOffsets ? ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0 : 0)) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win2 = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win2.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win2) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle(currentIFrame);
      iframeRect.x += (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      iframeRect.y += (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += iframeRect.x;
      y += iframeRect.y;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getDocumentElement(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = {
    x: 1,
    y: 1
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max2(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max2(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x += max2(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return parentNode.ownerDocument.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list) {
  var _node$ownerDocument;
  if (list === void 0) {
    list = [];
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isClientRectVisualViewportBased();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : {
    x: 1,
    y: 1
  };
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const mutableRect = {
      ...clippingAncestor
    };
    if (isClientRectVisualViewportBased()) {
      var _win$visualViewport, _win$visualViewport2;
      const win = getWindow(element);
      mutableRect.x -= ((_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) || 0;
      mutableRect.y -= ((_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) || 0;
    }
    rect = mutableRect;
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  return getCssDimensions(element);
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function getOffsetParent(element, polyfill) {
  const window2 = getWindow(element);
  if (!isHTMLElement(element)) {
    return window2;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const rect = getBoundingClientRect(element, true, strategy === "fixed", offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
var platform = {
  getClippingRect,
  convertOffsetParentRelativeRectToViewportRelativeRect,
  isElement,
  getDimensions,
  getOffsetParent,
  getDocumentElement,
  getScale,
  async getElementRects(_ref) {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
    const getDimensionsFn = this.getDimensions;
    return {
      reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
      floating: {
        x: 0,
        y: 0,
        ...await getDimensionsFn(floating)
      }
    };
  },
  getClientRects: (element) => Array.from(element.getClientRects()),
  isRTL: (element) => getComputedStyle$1(element).direction === "rtl"
};
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = true,
    animationFrame = false
  } = options;
  const ancestors = ancestorScroll || ancestorResize ? [...isElement(reference) ? getOverflowAncestors(reference) : reference.contextElement ? getOverflowAncestors(reference.contextElement) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    const isVisualViewport = !isElement(ancestor) && ancestor.toString().includes("V");
    if (ancestorScroll && (animationFrame ? isVisualViewport : true)) {
      ancestor.addEventListener("scroll", update, {
        passive: true
      });
    }
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  let observer = null;
  if (elementResize) {
    observer = new ResizeObserver(() => {
      update();
    });
    isElement(reference) && !animationFrame && observer.observe(reference);
    if (!isElement(reference) && reference.contextElement && !animationFrame) {
      observer.observe(reference.contextElement);
    }
    observer.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _observer;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    (_observer = observer) == null ? void 0 : _observer.disconnect();
    observer = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js
var React = __toESM(require_react());
var import_react = __toESM(require_react());
var ReactDOM = __toESM(require_react_dom());
var arrow2 = (options) => {
  const {
    element,
    padding
  } = options;
  function isRef(value) {
    return Object.prototype.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(args) {
      if (isRef(element)) {
        if (element.current != null) {
          return arrow({
            element: element.current,
            padding
          }).fn(args);
        }
        return {};
      } else if (element) {
        return arrow({
          element,
          padding
        }).fn(args);
      }
      return {};
    }
  };
};
var index = typeof document !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length, i, keys;
  if (a && b && typeof a == "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length)
        return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function useLatestRef(value) {
  const ref = React.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React.useState({
    x: null,
    y: null,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const referenceRef = React.useRef(null);
  const floatingRef = React.useRef(null);
  const dataRef = React.useRef(data);
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const [reference, _setReference] = React.useState(null);
  const [floating, _setFloating] = React.useState(null);
  const setReference = React.useCallback((node) => {
    if (referenceRef.current !== node) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React.useCallback((node) => {
    if (floatingRef.current !== node) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const update = React.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        isPositioned: true
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (reference && floating) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(reference, floating, update);
      } else {
        update();
      }
    }
  }, [reference, floating, update, whileElementsMountedRef]);
  const refs = React.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React.useMemo(() => ({
    reference,
    floating
  }), [reference, floating]);
  return React.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    reference: setReference,
    floating: setFloating
  }), [data, update, refs, elements, setReference, setFloating]);
}

// node_modules/@floating-ui/react/dist/floating-ui.react.esm.js
var index2 = typeof document !== "undefined" ? import_react2.useLayoutEffect : import_react2.useEffect;
var useReactId = React2["useId".toString()];
function createPubSub() {
  const map = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map.get(event)) == null ? void 0 : _map$get.forEach((handler) => handler(data));
    },
    on(event, listener) {
      map.set(event, [...map.get(event) || [], listener]);
    },
    off(event, listener) {
      map.set(event, (map.get(event) || []).filter((l) => l !== listener));
    }
  };
}
var FloatingNodeContext = React2.createContext(null);
var FloatingTreeContext = React2.createContext(null);
var useFloatingTree = () => React2.useContext(FloatingTreeContext);
function getDocument(node) {
  return (node == null ? void 0 : node.ownerDocument) || document;
}
function getPlatform() {
  const uaData = navigator.userAgentData;
  if (uaData != null && uaData.platform) {
    return uaData.platform;
  }
  return navigator.platform;
}
function getWindow2(value) {
  return getDocument(value).defaultView || window;
}
function isElement2(value) {
  return value ? value instanceof getWindow2(value).Element : false;
}
function isSafari() {
  return /apple/i.test(navigator.vendor);
}
function isMac() {
  return getPlatform().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
}
var FloatingDelayGroupContext = React2.createContext({
  delay: 0,
  initialDelay: 0,
  timeoutMs: 0,
  currentId: null,
  setCurrentId: () => {
  },
  setState: () => {
  },
  isInstantPhase: false
});
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var useInsertionEffect = React2["useInsertionEffect".toString()];
var useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
function useEvent(callback) {
  const ref = React2.useRef(() => {
    if (import_process.default.env.NODE_ENV !== "production") {
      throw new Error("Cannot call an event handler while rendering.");
    }
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return React2.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
var HIDDEN_STYLES = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
};
var activeElement;
var timeoutId;
function setActiveElementOnTab(event) {
  if (event.key === "Tab") {
    activeElement = event.target;
    clearTimeout(timeoutId);
  }
}
function isTabFocus(event) {
  const result = activeElement === event.relatedTarget;
  activeElement = event.relatedTarget;
  clearTimeout(timeoutId);
  return result;
}
var FocusGuard = React2.forwardRef(function FocusGuard2(props, ref) {
  const onFocus = useEvent(props.onFocus);
  const [role, setRole] = React2.useState();
  index2(() => {
    if (isSafari()) {
      setRole("button");
    }
    document.addEventListener("keydown", setActiveElementOnTab);
    return () => {
      document.removeEventListener("keydown", setActiveElementOnTab);
    };
  }, []);
  return React2.createElement("span", _extends({}, props, {
    ref,
    tabIndex: 0,
    role,
    "aria-hidden": role ? void 0 : true,
    "data-floating-ui-focus-guard": "",
    style: HIDDEN_STYLES,
    onFocus: (event) => {
      if (isSafari() && isMac() && !isTabFocus(event)) {
        event.persist();
        timeoutId = window.setTimeout(() => {
          onFocus(event);
        }, 50);
      } else {
        onFocus(event);
      }
    }
  }));
});
var PortalContext = React2.createContext(null);
var VisuallyHiddenDismiss = React2.forwardRef(function VisuallyHiddenDismiss2(props, ref) {
  return React2.createElement("button", _extends({}, props, {
    type: "button",
    ref,
    tabIndex: -1,
    style: HIDDEN_STYLES
  }));
});
var identifier = "data-floating-ui-scroll-lock";
var FloatingOverlay = React2.forwardRef(function FloatingOverlay2(_ref, ref) {
  let {
    lockScroll = false,
    ...rest
  } = _ref;
  index2(() => {
    var _window$visualViewpor, _window$visualViewpor2;
    if (!lockScroll) {
      return;
    }
    const alreadyLocked = document.body.hasAttribute(identifier);
    if (alreadyLocked) {
      return;
    }
    document.body.setAttribute(identifier, "");
    const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;
    const paddingProp = scrollbarX ? "paddingLeft" : "paddingRight";
    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    if (!/iP(hone|ad|od)|iOS/.test(getPlatform())) {
      Object.assign(document.body.style, {
        overflow: "hidden",
        [paddingProp]: scrollbarWidth + "px"
      });
      return () => {
        document.body.removeAttribute(identifier);
        Object.assign(document.body.style, {
          overflow: "",
          [paddingProp]: ""
        });
      };
    }
    const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;
    const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;
    const scrollX = window.pageXOffset;
    const scrollY = window.pageYOffset;
    Object.assign(document.body.style, {
      position: "fixed",
      overflow: "hidden",
      top: -(scrollY - Math.floor(offsetTop)) + "px",
      left: -(scrollX - Math.floor(offsetLeft)) + "px",
      right: "0",
      [paddingProp]: scrollbarWidth + "px"
    });
    return () => {
      Object.assign(document.body.style, {
        position: "",
        overflow: "",
        top: "",
        left: "",
        right: "",
        [paddingProp]: ""
      });
      document.body.removeAttribute(identifier);
      window.scrollTo(scrollX, scrollY);
    };
  }, [lockScroll]);
  return React2.createElement("div", _extends({
    ref
  }, rest, {
    style: {
      position: "fixed",
      overflow: "auto",
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...rest.style
    }
  }));
});
function useFloating2(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    open = false,
    onOpenChange: unstable_onOpenChange,
    nodeId
  } = options;
  const position = useFloating(options);
  const tree = useFloatingTree();
  const domReferenceRef = React2.useRef(null);
  const dataRef = React2.useRef({});
  const events = React2.useState(() => createPubSub())[0];
  const [domReference, setDomReference] = React2.useState(null);
  const setPositionReference = React2.useCallback((node) => {
    const positionReference = isElement2(node) ? {
      getBoundingClientRect: () => node.getBoundingClientRect(),
      contextElement: node
    } : node;
    position.refs.setReference(positionReference);
  }, [position.refs]);
  const setReference = React2.useCallback((node) => {
    if (isElement2(node) || node === null) {
      domReferenceRef.current = node;
      setDomReference(node);
    }
    if (isElement2(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node !== null && !isElement2(node)) {
      position.refs.setReference(node);
    }
  }, [position.refs]);
  const refs = React2.useMemo(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]);
  const elements = React2.useMemo(() => ({
    ...position.elements,
    domReference
  }), [position.elements, domReference]);
  const onOpenChange = useEvent(unstable_onOpenChange);
  const context = React2.useMemo(() => ({
    ...position,
    refs,
    elements,
    dataRef,
    nodeId,
    events,
    open,
    onOpenChange
  }), [position, nodeId, events, open, onOpenChange, refs, elements]);
  index2(() => {
    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);
    if (node) {
      node.context = context;
    }
  });
  return React2.useMemo(() => ({
    ...position,
    context,
    refs,
    reference: setReference,
    positionReference: setPositionReference
  }), [position, refs, context, setReference, setPositionReference]);
}

// node_modules/@headlessui-float/react/dist/headlessui-float.mjs
var $t = Object.defineProperty;
var Dt = (t, a, o) => a in t ? $t(t, a, { enumerable: true, configurable: true, writable: true, value: o }) : t[a] = o;
var Xe = (t, a, o) => (Dt(t, typeof a != "symbol" ? a + "" : a, o), o);
var xe = {};
var Jt = {
  get exports() {
    return xe;
  },
  set exports(t) {
    xe = t;
  }
};
var G = {};
var Ge;
function Gt() {
  if (Ge)
    return G;
  Ge = 1;
  var t = import_react3.default, a = Symbol.for("react.element"), o = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, u = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, y = { key: true, ref: true, __self: true, __source: true };
  function d(m, v, b) {
    var s, c = {}, _ = null, l = null;
    b !== void 0 && (_ = "" + b), v.key !== void 0 && (_ = "" + v.key), v.ref !== void 0 && (l = v.ref);
    for (s in v)
      n.call(v, s) && !y.hasOwnProperty(s) && (c[s] = v[s]);
    if (m && m.defaultProps)
      for (s in v = m.defaultProps, v)
        c[s] === void 0 && (c[s] = v[s]);
    return { $$typeof: a, type: m, key: _, ref: l, props: c, _owner: u.current };
  }
  return G.Fragment = o, G.jsx = d, G.jsxs = d, G;
}
var H = {};
var He;
function Ht() {
  return He || (He = 1, import_process.default.env.NODE_ENV !== "production" && function() {
    var t = import_react3.default, a = Symbol.for("react.element"), o = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), u = Symbol.for("react.strict_mode"), y = Symbol.for("react.profiler"), d = Symbol.for("react.provider"), m = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), b = Symbol.for("react.suspense"), s = Symbol.for("react.suspense_list"), c = Symbol.for("react.memo"), _ = Symbol.for("react.lazy"), l = Symbol.for("react.offscreen"), S = Symbol.iterator, A = "@@iterator";
    function W(e) {
      if (e === null || typeof e != "object")
        return null;
      var r = S && e[S] || e[A];
      return typeof r == "function" ? r : null;
    }
    var T = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function R(e) {
      {
        for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), f = 1; f < r; f++)
          i[f - 1] = arguments[f];
        M("error", e, i);
      }
    }
    function M(e, r, i) {
      {
        var f = T.ReactDebugCurrentFrame, E = f.getStackAddendum();
        E !== "" && (r += "%s", i = i.concat([E]));
        var p = i.map(function(g) {
          return String(g);
        });
        p.unshift("Warning: " + r), Function.prototype.apply.call(console[e], console, p);
      }
    }
    var j = false, L = false, N = false, X = false, Z = false, ue;
    ue = Symbol.for("react.module.reference");
    function Fe(e) {
      return !!(typeof e == "string" || typeof e == "function" || e === n || e === y || Z || e === u || e === b || e === s || X || e === l || j || L || N || typeof e == "object" && e !== null && (e.$$typeof === _ || e.$$typeof === c || e.$$typeof === d || e.$$typeof === m || e.$$typeof === v || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      e.$$typeof === ue || e.getModuleId !== void 0));
    }
    function ke(e, r, i) {
      var f = e.displayName;
      if (f)
        return f;
      var E = r.displayName || r.name || "";
      return E !== "" ? i + "(" + E + ")" : i;
    }
    function ce(e) {
      return e.displayName || "Context";
    }
    function $(e) {
      if (e == null)
        return null;
      if (typeof e.tag == "number" && R("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof e == "function")
        return e.displayName || e.name || null;
      if (typeof e == "string")
        return e;
      switch (e) {
        case n:
          return "Fragment";
        case o:
          return "Portal";
        case y:
          return "Profiler";
        case u:
          return "StrictMode";
        case b:
          return "Suspense";
        case s:
          return "SuspenseList";
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case m:
            var r = e;
            return ce(r) + ".Consumer";
          case d:
            var i = e;
            return ce(i._context) + ".Provider";
          case v:
            return ke(e, e.render, "ForwardRef");
          case c:
            var f = e.displayName || null;
            return f !== null ? f : $(e.type) || "Memo";
          case _: {
            var E = e, p = E._payload, g = E._init;
            try {
              return $(g(p));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Y = Object.assign, U = 0, se, le, fe, de, ve, he, me;
    function Q() {
    }
    Q.__reactDisabledLog = true;
    function st() {
      {
        if (U === 0) {
          se = console.log, le = console.info, fe = console.warn, de = console.error, ve = console.group, he = console.groupCollapsed, me = console.groupEnd;
          var e = {
            configurable: true,
            enumerable: true,
            value: Q,
            writable: true
          };
          Object.defineProperties(console, {
            info: e,
            log: e,
            warn: e,
            error: e,
            group: e,
            groupCollapsed: e,
            groupEnd: e
          });
        }
        U++;
      }
    }
    function lt() {
      {
        if (U--, U === 0) {
          var e = {
            configurable: true,
            enumerable: true,
            writable: true
          };
          Object.defineProperties(console, {
            log: Y({}, e, {
              value: se
            }),
            info: Y({}, e, {
              value: le
            }),
            warn: Y({}, e, {
              value: fe
            }),
            error: Y({}, e, {
              value: de
            }),
            group: Y({}, e, {
              value: ve
            }),
            groupCollapsed: Y({}, e, {
              value: he
            }),
            groupEnd: Y({}, e, {
              value: me
            })
          });
        }
        U < 0 && R("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ge = T.ReactCurrentDispatcher, ye;
    function ee(e, r, i) {
      {
        if (ye === void 0)
          try {
            throw Error();
          } catch (E) {
            var f = E.stack.trim().match(/\n( *(at )?)/);
            ye = f && f[1] || "";
          }
        return `
` + ye + e;
      }
    }
    var be = false, te2;
    {
      var ft = typeof WeakMap == "function" ? WeakMap : Map;
      te2 = new ft();
    }
    function Ae(e, r) {
      if (!e || be)
        return "";
      {
        var i = te2.get(e);
        if (i !== void 0)
          return i;
      }
      var f;
      be = true;
      var E = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var p;
      p = ge.current, ge.current = null, st();
      try {
        if (r) {
          var g = function() {
            throw Error();
          };
          if (Object.defineProperty(g.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(g, []);
            } catch (I) {
              f = I;
            }
            Reflect.construct(e, [], g);
          } else {
            try {
              g.call();
            } catch (I) {
              f = I;
            }
            e.call(g.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (I) {
            f = I;
          }
          e();
        }
      } catch (I) {
        if (I && f && typeof I.stack == "string") {
          for (var h = I.stack.split(`
`), O = f.stack.split(`
`), x = h.length - 1, C = O.length - 1; x >= 1 && C >= 0 && h[x] !== O[C]; )
            C--;
          for (; x >= 1 && C >= 0; x--, C--)
            if (h[x] !== O[C]) {
              if (x !== 1 || C !== 1)
                do
                  if (x--, C--, C < 0 || h[x] !== O[C]) {
                    var F = `
` + h[x].replace(" at new ", " at ");
                    return e.displayName && F.includes("<anonymous>") && (F = F.replace("<anonymous>", e.displayName)), typeof e == "function" && te2.set(e, F), F;
                  }
                while (x >= 1 && C >= 0);
              break;
            }
        }
      } finally {
        be = false, ge.current = p, lt(), Error.prepareStackTrace = E;
      }
      var B = e ? e.displayName || e.name : "", qe = B ? ee(B) : "";
      return typeof e == "function" && te2.set(e, qe), qe;
    }
    function dt(e, r, i) {
      return Ae(e, false);
    }
    function vt(e) {
      var r = e.prototype;
      return !!(r && r.isReactComponent);
    }
    function re(e, r, i) {
      if (e == null)
        return "";
      if (typeof e == "function")
        return Ae(e, vt(e));
      if (typeof e == "string")
        return ee(e);
      switch (e) {
        case b:
          return ee("Suspense");
        case s:
          return ee("SuspenseList");
      }
      if (typeof e == "object")
        switch (e.$$typeof) {
          case v:
            return dt(e.render);
          case c:
            return re(e.type, r, i);
          case _: {
            var f = e, E = f._payload, p = f._init;
            try {
              return re(p(E), r, i);
            } catch {
            }
          }
        }
      return "";
    }
    var ne = Object.prototype.hasOwnProperty, $e = {}, De = T.ReactDebugCurrentFrame;
    function oe(e) {
      if (e) {
        var r = e._owner, i = re(e.type, e._source, r ? r.type : null);
        De.setExtraStackFrame(i);
      } else
        De.setExtraStackFrame(null);
    }
    function ht(e, r, i, f, E) {
      {
        var p = Function.call.bind(ne);
        for (var g in e)
          if (p(e, g)) {
            var h = void 0;
            try {
              if (typeof e[g] != "function") {
                var O = Error((f || "React class") + ": " + i + " type `" + g + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof e[g] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw O.name = "Invariant Violation", O;
              }
              h = e[g](r, g, f, i, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (x) {
              h = x;
            }
            h && !(h instanceof Error) && (oe(E), R("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", f || "React class", i, g, typeof h), oe(null)), h instanceof Error && !(h.message in $e) && ($e[h.message] = true, oe(E), R("Failed %s type: %s", i, h.message), oe(null));
          }
      }
    }
    var mt = Array.isArray;
    function Ee(e) {
      return mt(e);
    }
    function gt(e) {
      {
        var r = typeof Symbol == "function" && Symbol.toStringTag, i = r && e[Symbol.toStringTag] || e.constructor.name || "Object";
        return i;
      }
    }
    function yt(e) {
      try {
        return Ie(e), false;
      } catch {
        return true;
      }
    }
    function Ie(e) {
      return "" + e;
    }
    function We(e) {
      if (yt(e))
        return R("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", gt(e)), Ie(e);
    }
    var J = T.ReactCurrentOwner, bt = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    }, Ye, Le, we;
    we = {};
    function Et(e) {
      if (ne.call(e, "ref")) {
        var r = Object.getOwnPropertyDescriptor(e, "ref").get;
        if (r && r.isReactWarning)
          return false;
      }
      return e.ref !== void 0;
    }
    function wt(e) {
      if (ne.call(e, "key")) {
        var r = Object.getOwnPropertyDescriptor(e, "key").get;
        if (r && r.isReactWarning)
          return false;
      }
      return e.key !== void 0;
    }
    function pt(e, r) {
      if (typeof e.ref == "string" && J.current && r && J.current.stateNode !== r) {
        var i = $(J.current.type);
        we[i] || (R('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', $(J.current.type), e.ref), we[i] = true);
      }
    }
    function Rt(e, r) {
      {
        var i = function() {
          Ye || (Ye = true, R("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", r));
        };
        i.isReactWarning = true, Object.defineProperty(e, "key", {
          get: i,
          configurable: true
        });
      }
    }
    function _t(e, r) {
      {
        var i = function() {
          Le || (Le = true, R("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", r));
        };
        i.isReactWarning = true, Object.defineProperty(e, "ref", {
          get: i,
          configurable: true
        });
      }
    }
    var xt = function(e, r, i, f, E, p, g) {
      var h = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: a,
        // Built-in properties that belong on the element
        type: e,
        key: r,
        ref: i,
        props: g,
        // Record the component responsible for creating this element.
        _owner: p
      };
      return h._store = {}, Object.defineProperty(h._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      }), Object.defineProperty(h, "_self", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: f
      }), Object.defineProperty(h, "_source", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: E
      }), Object.freeze && (Object.freeze(h.props), Object.freeze(h)), h;
    };
    function Ct(e, r, i, f, E) {
      {
        var p, g = {}, h = null, O = null;
        i !== void 0 && (We(i), h = "" + i), wt(r) && (We(r.key), h = "" + r.key), Et(r) && (O = r.ref, pt(r, E));
        for (p in r)
          ne.call(r, p) && !bt.hasOwnProperty(p) && (g[p] = r[p]);
        if (e && e.defaultProps) {
          var x = e.defaultProps;
          for (p in x)
            g[p] === void 0 && (g[p] = x[p]);
        }
        if (h || O) {
          var C = typeof e == "function" ? e.displayName || e.name || "Unknown" : e;
          h && Rt(g, C), O && _t(g, C);
        }
        return xt(e, h, O, E, f, J.current, g);
      }
    }
    var pe = T.ReactCurrentOwner, Ne = T.ReactDebugCurrentFrame;
    function V(e) {
      if (e) {
        var r = e._owner, i = re(e.type, e._source, r ? r.type : null);
        Ne.setExtraStackFrame(i);
      } else
        Ne.setExtraStackFrame(null);
    }
    var Re;
    Re = false;
    function _e(e) {
      return typeof e == "object" && e !== null && e.$$typeof === a;
    }
    function Me() {
      {
        if (pe.current) {
          var e = $(pe.current.type);
          if (e)
            return `

Check the render method of \`` + e + "`.";
        }
        return "";
      }
    }
    function Tt(e) {
      {
        if (e !== void 0) {
          var r = e.fileName.replace(/^.*[\\\/]/, ""), i = e.lineNumber;
          return `

Check your code at ` + r + ":" + i + ".";
        }
        return "";
      }
    }
    var Ue = {};
    function Pt(e) {
      {
        var r = Me();
        if (!r) {
          var i = typeof e == "string" ? e : e.displayName || e.name;
          i && (r = `

Check the top-level render call using <` + i + ">.");
        }
        return r;
      }
    }
    function Ve(e, r) {
      {
        if (!e._store || e._store.validated || e.key != null)
          return;
        e._store.validated = true;
        var i = Pt(r);
        if (Ue[i])
          return;
        Ue[i] = true;
        var f = "";
        e && e._owner && e._owner !== pe.current && (f = " It was passed a child from " + $(e._owner.type) + "."), V(e), R('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', i, f), V(null);
      }
    }
    function Be(e, r) {
      {
        if (typeof e != "object")
          return;
        if (Ee(e))
          for (var i = 0; i < e.length; i++) {
            var f = e[i];
            _e(f) && Ve(f, r);
          }
        else if (_e(e))
          e._store && (e._store.validated = true);
        else if (e) {
          var E = W(e);
          if (typeof E == "function" && E !== e.entries)
            for (var p = E.call(e), g; !(g = p.next()).done; )
              _e(g.value) && Ve(g.value, r);
        }
      }
    }
    function Ot(e) {
      {
        var r = e.type;
        if (r == null || typeof r == "string")
          return;
        var i;
        if (typeof r == "function")
          i = r.propTypes;
        else if (typeof r == "object" && (r.$$typeof === v || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        r.$$typeof === c))
          i = r.propTypes;
        else
          return;
        if (i) {
          var f = $(r);
          ht(i, e.props, "prop", f, e);
        } else if (r.PropTypes !== void 0 && !Re) {
          Re = true;
          var E = $(r);
          R("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", E || "Unknown");
        }
        typeof r.getDefaultProps == "function" && !r.getDefaultProps.isReactClassApproved && R("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function St(e) {
      {
        for (var r = Object.keys(e.props), i = 0; i < r.length; i++) {
          var f = r[i];
          if (f !== "children" && f !== "key") {
            V(e), R("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", f), V(null);
            break;
          }
        }
        e.ref !== null && (V(e), R("Invalid attribute `ref` supplied to `React.Fragment`."), V(null));
      }
    }
    function ze(e, r, i, f, E, p) {
      {
        var g = Fe(e);
        if (!g) {
          var h = "";
          (e === void 0 || typeof e == "object" && e !== null && Object.keys(e).length === 0) && (h += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var O = Tt(E);
          O ? h += O : h += Me();
          var x;
          e === null ? x = "null" : Ee(e) ? x = "array" : e !== void 0 && e.$$typeof === a ? (x = "<" + ($(e.type) || "Unknown") + " />", h = " Did you accidentally export a JSX literal instead of a component?") : x = typeof e, R("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", x, h);
        }
        var C = Ct(e, r, i, E, p);
        if (C == null)
          return C;
        if (g) {
          var F = r.children;
          if (F !== void 0)
            if (f)
              if (Ee(F)) {
                for (var B = 0; B < F.length; B++)
                  Be(F[B], e);
                Object.freeze && Object.freeze(F);
              } else
                R("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Be(F, e);
        }
        return e === n ? St(C) : Ot(C), C;
      }
    }
    function jt(e, r, i) {
      return ze(e, r, i, true);
    }
    function Ft(e, r, i) {
      return ze(e, r, i, false);
    }
    var kt = Ft, At = jt;
    H.Fragment = n, H.jsx = kt, H.jsxs = At;
  }()), H;
}
(function(t) {
  import_process.default.env.NODE_ENV === "production" ? t.exports = Gt() : t.exports = Ht();
})(Jt);
var w = xe.jsx;
var Kt = class {
  constructor() {
    Xe(this, "current", this.detect());
  }
  set(a) {
    this.current !== a && (this.current = a);
  }
  reset() {
    this.set(this.detect());
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
};
var ie = new Kt();
function Zt(t, a, o, n) {
  (0, import_react3.useEffect)(() => {
    const u = [];
    (typeof n.offset == "number" || typeof n.offset == "object" || typeof n.offset == "function") && u.push(offset(n.offset)), (n.flip === true || typeof n.flip == "number" || typeof n.flip == "object") && u.push(flip({
      padding: typeof n.flip == "number" ? n.flip : void 0,
      ...typeof n.flip == "object" ? n.flip : {}
    })), (n.shift === true || typeof n.shift == "number" || typeof n.shift == "object") && u.push(shift({
      padding: typeof n.shift == "number" ? n.shift : void 0,
      ...typeof n.shift == "object" ? n.shift : {}
    })), (n.autoPlacement === true || typeof n.autoPlacement == "object") && u.push(autoPlacement(
      typeof n.autoPlacement == "object" ? n.autoPlacement : void 0
    )), (n.arrow === true || typeof n.arrow == "number") && u.push(arrow2({
      element: o,
      padding: n.arrow === true ? 0 : n.arrow
    })), u.push(...typeof n.middleware == "function" ? n.middleware({
      referenceEl: a.reference,
      floatingEl: a.floating
    }) : n.middleware || []), (n.hide === true || typeof n.hide == "object") && u.push(hide(
      typeof n.hide == "object" ? n.hide : void 0
    )), t(u);
  }, [
    n.offset,
    n.shift,
    n.flip,
    n.arrow,
    n.autoPlacement,
    n.hide,
    n.middleware
  ]);
}
function Qt(t, a, o) {
  (0, import_react3.useEffect)(() => {
    if (t && ie.isClient && typeof ResizeObserver < "u" && a.current && a.current instanceof Element) {
      const n = new ResizeObserver(([u]) => {
        const y = u.borderBoxSize.reduce((d, { inlineSize: m }) => d + m, 0);
        o(y);
      });
      return n.observe(a.current), () => {
        n.disconnect(), o(null);
      };
    }
  }, []);
}
var gr = [
  "origin-bottom",
  "origin-top",
  "origin-right",
  "origin-left",
  "origin-bottom-left",
  "origin-bottom-right",
  "origin-top-left",
  "origin-top-right"
];
var er = (t) => {
  switch (t) {
    case "top":
      return "origin-bottom";
    case "bottom":
      return "origin-top";
    case "left":
      return "origin-right";
    case "right":
      return "origin-left";
    case "top-start":
    case "right-end":
      return "origin-bottom-left";
    case "top-end":
    case "left-end":
      return "origin-bottom-right";
    case "right-start":
    case "bottom-start":
      return "origin-top-left";
    case "left-start":
    case "bottom-end":
      return "origin-top-right";
    default:
      return "";
  }
};
function tr(t, a) {
  return (0, import_react3.useMemo)(() => typeof t.originClass == "function" ? t.originClass(a) : typeof t.originClass == "string" ? t.originClass : t.tailwindcssOriginClass ? er(a) : "", [a, t.originClass, t.tailwindcssOriginClass]);
}
function et(t, a, ...o) {
  if (t in a) {
    const u = a[t];
    return typeof u == "function" ? u(...o) : u;
  }
  const n = new Error(
    `Tried to handle "${t}" but there is no handler defined. Only defined handlers are: ${Object.keys(
      a
    ).map((u) => `"${u}"`).join(", ")}.`
  );
  throw Error.captureStackTrace && Error.captureStackTrace(n, et), n;
}
function tt2(t) {
  return ie.isServer ? null : t instanceof Node ? t.ownerDocument : t && Object.prototype.hasOwnProperty.call(t, "current") && t.current instanceof Node ? t.current.ownerDocument : document;
}
var Ke = [
  "[contentEditable=true]",
  "[tabindex]",
  "a[href]",
  "area[href]",
  "button:not([disabled])",
  "iframe",
  "input:not([disabled])",
  "select:not([disabled])",
  "textarea:not([disabled])"
].map(
  // TODO: Remove this once JSDOM fixes the issue where an element that is
  // "hidden" can be the document.activeElement, because this is not possible
  // in real browsers.
  import_process.default.env.NODE_ENV === "test" ? (t) => `${t}:not([tabindex='-1']):not([style*='display: none'])` : (t) => `${t}:not([tabindex='-1'])`
).join(",");
var rt = ((t) => (t[t.Strict = 0] = "Strict", t[t.Loose = 1] = "Loose", t))(rt || {});
function rr(t, a = 0) {
  var o;
  return t === ((o = tt2(t)) == null ? void 0 : o.body) ? false : et(a, {
    [
      0
      /* Strict */
    ]() {
      return t.matches(Ke);
    },
    [
      1
      /* Loose */
    ]() {
      let n = t;
      for (; n !== null; ) {
        if (n.matches(Ke))
          return true;
        n = n.parentElement;
      }
      return false;
    }
  });
}
var nr = (t, a) => {
  ie.isServer ? (0, import_react3.useEffect)(t, a) : (0, import_react3.useLayoutEffect)(t, a);
};
function or(t) {
  const a = (0, import_react3.useRef)(t);
  return nr(() => {
    a.current = t;
  }, [t]), a;
}
function D(t, a, o) {
  const n = or(a);
  (0, import_react3.useEffect)(() => {
    function u(y) {
      n.current(y);
    }
    return document.addEventListener(t, u, o), () => document.removeEventListener(t, u, o);
  }, [t, o]);
}
function ar(t, a, o = true) {
  const n = (0, import_react3.useRef)(false);
  (0, import_react3.useEffect)(
    import_process.default.env.NODE_ENV === "test" ? () => {
      n.current = o;
    } : () => {
      requestAnimationFrame(() => {
        n.current = o;
      });
    },
    [o]
  );
  function u(d, m) {
    if (!n.current || d.defaultPrevented)
      return;
    const v = function s(c) {
      return typeof c == "function" ? s(c()) : Array.isArray(c) || c instanceof Set ? c : [c];
    }(t), b = m(d);
    if (b !== null && b.getRootNode().contains(b)) {
      for (const s of v) {
        if (s === null)
          continue;
        const c = s instanceof HTMLElement ? s : s.current;
        if (c != null && c.contains(b) || d.composed && d.composedPath().includes(c))
          return;
      }
      return (
        // This check alllows us to know whether or not we clicked on a "focusable" element like a
        // button or an input. This is a backwards compatibility check so that you can open a <Menu
        // /> and click on another <Menu /> which should close Menu A and open Menu B. We might
        // revisit that so that you will require 2 clicks instead.
        !rr(b, rt.Loose) && // This could be improved, but the `Combobox.Button` adds tabIndex={-1} to make it
        // unfocusable via the keyboard so that tabbing to the next item from the input doesn't
        // first go to the button.
        b.tabIndex !== -1 && d.preventDefault(), a(d, b)
      );
    }
  }
  const y = (0, import_react3.useRef)(null);
  D("mousedown", (d) => {
    var m, v;
    n.current && (y.current = ((v = (m = d.composedPath) == null ? void 0 : m.call(d)) == null ? void 0 : v[0]) || d.target);
  }, true), D(
    "click",
    (d) => {
      y.current && (u(d, () => y.current), y.current = null);
    },
    // We will use the `capture` phase so that layers in between with `event.stopPropagation()`
    // don't "cancel" this outside click check. E.g.: A `Menu` inside a `DialogPanel` if the `Menu`
    // is open, and you click outside of it in the `DialogPanel` the `Menu` should close. However,
    // the `DialogPanel` has a `onClick(e) { e.stopPropagation() }` which would cancel this.
    true
  ), D("blur", (d) => u(
    d,
    () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null
  ), true);
}
var Pe = (0, import_react3.createContext)(null);
Pe.displayName = "ReferenceContext";
var Oe = (0, import_react3.createContext)(null);
Oe.displayName = "FloatingContext";
var K = (0, import_react3.createContext)(null);
K.displayName = "ArrowContext";
function nt(t) {
  const a = (0, import_react3.useContext)(Pe);
  if (a === null) {
    const o = new Error(`<${t} /> is missing a parent <Float /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o, nt), o;
  }
  return a;
}
function ot(t) {
  const a = (0, import_react3.useContext)(Oe);
  if (a === null) {
    const o = new Error(`<${t} /> is missing a parent <Float /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o, ot), o;
  }
  return a;
}
function at(t) {
  const a = (0, import_react3.useContext)(K);
  if (a === null) {
    const o = new Error(`<${t} /> is missing a parent <Float /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o, at), o;
  }
  return a;
}
function it(t, a, o, n) {
  const { referenceRef: u } = n, y = a;
  if (y.as === import_react3.Fragment)
    return w(
      t.type,
      {
        ...t.props,
        ...o,
        ref: u
      }
    );
  const d = y.as || "div";
  return w(d, { ...o, ref: u, children: w(t.type, { ...t.props }) });
}
function Se(t, a, o, n) {
  const { floatingRef: u, props: y, mounted: d, setShow: m, x: v, y: b, placement: s, strategy: c, referenceElWidth: _ } = n, l = {
    ...y,
    ...a
  }, S = tr(l, s), A = {
    show: d.current ? l.show : false,
    enter: `${l.enter || ""} ${S}`,
    enterFrom: `${l.enterFrom || ""}`,
    enterTo: `${l.enterTo || ""}`,
    leave: `${l.leave || ""} ${S}`,
    leaveFrom: `${l.leaveFrom || ""}`,
    leaveTo: `${l.leaveTo || ""}`,
    beforeEnter: () => {
      m(true);
    },
    afterLeave: () => {
      m(false);
    }
  }, W = {
    style: {
      // If enable dialog mode, then set `transform` to false.
      ...!l.dialog && (l.transform || l.transform === void 0) ? {
        position: c,
        zIndex: l.zIndex || 9999,
        top: "0px",
        left: "0px",
        right: "auto",
        bottom: "auto",
        transform: `translate(${Math.round(v || 0)}px,${Math.round(b || 0)}px)`
      } : {
        position: c,
        zIndex: l.zIndex || 9999,
        top: `${b || 0}px`,
        left: `${v || 0}px`
      },
      width: l.adaptiveWidth && typeof _ == "number" ? `${_}px` : void 0
    }
  };
  function T(j) {
    return l.portal ? w(te, { children: j }) : j;
  }
  function R(j) {
    const L = {
      ...W,
      ...o,
      ref: u
    };
    if (l.as === import_react3.Fragment)
      return w(
        j.type,
        {
          ...j.props,
          ...L
        }
      );
    const N = l.as || "div";
    return w(N, { ...L, children: w(j.type, { ...j.props }) });
  }
  function M() {
    return ie.isServer ? d.current && l.show ? w(t.type, { ...t.props }) : w(import_react3.Fragment, {}) : l.transitionChild ? w(tt.Child, { as: import_react3.Fragment, ...A, children: w(t.type, { ...t.props }) }) : w(tt, { as: import_react3.Fragment, ...A, children: w(t.type, { ...t.props }) });
  }
  return T(
    R(
      M()
    )
  );
}
function ut([t, a], o) {
  var N, X;
  const n = (0, import_react3.useRef)(false), [u, y] = (0, import_react3.useState)(), d = (0, import_react3.useRef)(null), m = (0, import_react3.useMemo)(() => ({
    show: o.onShow || (() => {
    }),
    hide: o.onHide || (() => {
    }),
    update: o.onUpdate || (() => {
    })
  }), [o.onShow, o.onHide, o.onUpdate]), { x: v, y: b, placement: s, strategy: c, update: _, refs: l, middlewareData: S } = useFloating2({
    placement: o.placement || "bottom-start",
    strategy: o.strategy,
    middleware: u
  }), [A, W] = (0, import_react3.useState)(null), T = (0, import_react3.useCallback)(() => {
    _(), m.update();
  }, [_, m]);
  (0, import_react3.useEffect)(T, [o.placement, o.strategy, u]), Zt(y, l, d, o), (0, import_react3.useEffect)(() => {
    n.current = true;
  }, []), Qt(o.adaptiveWidth, l.reference, W), (0, import_react3.useEffect)(() => {
    if (l.reference.current && l.floating.current && t) {
      const Z = o.autoUpdate !== false ? autoUpdate(
        l.reference.current,
        l.floating.current,
        T,
        typeof o.autoUpdate == "object" ? o.autoUpdate : void 0
      ) : () => {
      };
      return m.show(), () => {
        Z(), m.hide();
      };
    }
  }, [t, T, l]);
  const R = (0, import_react3.useRef)(true);
  (0, import_react3.useEffect)(() => {
    !(l.reference.current instanceof Element) && l.reference.current && l.floating.current && R.current && (R.current = false, T(), window.requestAnimationFrame(() => {
      R.current = true, T();
    }));
  }, [l]);
  const M = {
    referenceRef: l.setReference,
    placement: s
  }, j = {
    floatingRef: l.setFloating,
    props: o,
    mounted: n,
    setShow: a,
    x: v,
    y: b,
    placement: s,
    strategy: c,
    referenceElWidth: A
  }, L = {
    arrowRef: d,
    placement: s,
    x: (N = S.arrow) == null ? void 0 : N.x,
    y: (X = S.arrow) == null ? void 0 : X.y
  };
  return { referenceApi: M, floatingApi: j, arrowApi: L, x: v, y: b, placement: s, strategy: c, update: T, refs: l, middlewareData: S };
}
var ct = (0, import_react3.forwardRef)((t, a) => {
  const [o, n] = (0, import_react3.useState)(t.show ?? false), {
    referenceApi: u,
    floatingApi: y,
    arrowApi: d,
    placement: m
  } = ut([o, n], t), v = { placement: m }, [b, s] = typeof t.children == "function" ? t.children(v) : t.children;
  if (!(0, import_react3.isValidElement)(b))
    return console.warn("<Float /> is missing a reference and floating element."), w(import_react3.Fragment, {});
  function c(S) {
    if (t.as === import_react3.Fragment || !t.as)
      return w(import_react3.Fragment, { children: S });
    const A = t.as || "div";
    return w(A, { ref: a, className: t.className, children: S });
  }
  if (t.composable || t.dialog)
    return c(
      w(Pe.Provider, { value: u, children: w(Oe.Provider, { value: y, children: w(K.Provider, { value: d, children: typeof t.children == "function" ? t.children(v) : t.children }) }) }, "FloatingNode")
    );
  const _ = it(
    b,
    { as: import_react3.Fragment },
    { key: "reference-node" },
    u
  ), l = Se(
    s,
    { as: t.floatingAs || "div" },
    {},
    y
  );
  return c([
    _,
    w(K.Provider, { value: d, children: l }, "floating-node")
  ]);
});
ct.displayName = "Float";
function ir(t) {
  if (!t.children)
    return w(import_react3.Fragment, {});
  const a = (0, import_react3.useMemo)(() => {
    const { as: y, children: d, ...m } = t;
    return m;
  }, [t]), o = nt("Float.Reference"), { placement: n } = o, u = { placement: n };
  return it(
    typeof t.children == "function" ? t.children(u) : t.children,
    { ...t, as: t.as || import_react3.Fragment },
    a,
    o
  );
}
function ur(t) {
  if (!t.children)
    return w(import_react3.Fragment, {});
  const a = (0, import_react3.useMemo)(() => {
    const { as: y, enter: d, enterFrom: m, enterTo: v, leave: b, leaveFrom: s, leaveTo: c, originClass: _, tailwindcssOriginClass: l, transitionChild: S, children: A, ...W } = t;
    return W;
  }, [t]), o = ot("Float.Content"), { placement: n } = o, u = { placement: n };
  return Se(
    typeof t.children == "function" ? t.children(u) : t.children,
    { ...t, as: t.as || "div" },
    a,
    o
  );
}
function cr(t) {
  const { arrowRef: a, placement: o, x: n, y: u } = at("Float.Arrow"), y = (0, import_react3.useMemo)(() => {
    const { as: b, offset: s, children: c, ..._ } = t;
    return _;
  }, [t]), d = {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
  }[o.split("-")[0]], m = {
    left: typeof n == "number" ? `${n}px` : void 0,
    top: typeof u == "number" ? `${u}px` : void 0,
    right: void 0,
    bottom: void 0,
    [d]: `${(t.offset ?? 4) * -1}px`,
    ...y.style
  };
  if (t.as === import_react3.Fragment) {
    const b = { placement: o }, s = typeof t.children == "function" ? t.children(b) : t.children;
    return !s || !(0, import_react3.isValidElement)(s) ? w(import_react3.Fragment, {}) : w(
      s.type,
      {
        ...s.props,
        ref: a,
        style: m
      }
    );
  }
  const v = t.as || "div";
  return w(
    v,
    {
      ref: a,
      ...y,
      style: m,
      children: t.children
    }
  );
}
function je({ onInitial: t, children: a, ...o }) {
  const [n, u] = (0, import_react3.useState)(o.show ?? false), y = (0, import_react3.useMemo)(() => {
    const { as: l, show: S, placement: A, strategy: W, offset: T, shift: R, flip: M, arrow: j, autoPlacement: L, hide: N, autoUpdate: X, zIndex: Z, enter: ue, enterFrom: Fe, enterTo: ke, leave: ce, leaveFrom: $, leaveTo: Y, originClass: U, tailwindcssOriginClass: se, portal: le, transform: fe, middleware: de, onShow: ve, onHide: he, onUpdate: me, ...Q } = o;
    return Q;
  }, [o]), {
    floatingApi: d,
    arrowApi: m,
    placement: v,
    refs: b
  } = ut([n, u], o);
  (0, import_react3.useEffect)(() => {
    u(o.show ?? false);
  }, [o.show]);
  function s() {
    n && u(false);
  }
  if (t({ show: n, setShow: u, placement: v, refs: b }), !a)
    return w(import_react3.Fragment, {});
  const _ = Se(
    typeof a == "function" ? a({ placement: v, close: s }) : a,
    {
      ...o,
      as: o.as || import_react3.Fragment,
      show: n
    },
    y,
    d
  );
  return w(K.Provider, { value: m, children: _ });
}
function sr(t) {
  function a({ setShow: o, refs: n }) {
    D("contextmenu", (u) => {
      u.preventDefault(), n.setPositionReference({
        getBoundingClientRect() {
          return {
            width: 0,
            height: 0,
            x: u.clientX,
            y: u.clientY,
            top: u.clientY,
            left: u.clientX,
            right: u.clientX,
            bottom: u.clientY
          };
        }
      }), o(true);
    }), ar(n.floating, () => {
      o(false);
    });
  }
  return w(
    je,
    {
      flip: true,
      ...t,
      show: false,
      portal: true,
      onInitial: a
    }
  );
}
function lr({ globalHideCursor: t, ...a }) {
  function o({ setShow: n, refs: u }) {
    function y() {
      n(true);
    }
    function d() {
      n(false);
    }
    function m(c) {
      u.setPositionReference({
        getBoundingClientRect() {
          return {
            width: 0,
            height: 0,
            x: c.clientX,
            y: c.clientY,
            top: c.clientY,
            left: c.clientX,
            right: c.clientX,
            bottom: c.clientY
          };
        }
      });
    }
    function v(c) {
      y(), m(c);
    }
    function b(c) {
      y(), m(c.touches[0]);
    }
    const s = tt2(u.floating);
    s && ((0, import_react3.useEffect)(() => {
      if ((t || t === void 0) && !s.getElementById("headlesui-float-cursor-style")) {
        const c = s.createElement("style");
        return (s.head || s.getElementsByTagName("head")[0]).appendChild(c), c.id = "headlesui-float-cursor-style", c.appendChild(s.createTextNode([
          "*, *::before, *::after {",
          "  cursor: none !important;",
          "}",
          ".headlesui-float-cursor-root {",
          "  pointer-events: none !important;",
          "}"
        ].join(`
`))), () => {
          var l;
          return (l = s.getElementById("headlesui-float-cursor-style")) == null ? void 0 : l.remove();
        };
      }
    }, [t]), "ontouchstart" in window || navigator.maxTouchPoints > 0 ? (D("touchstart", b), D("touchend", d), D("touchmove", b)) : (D("mouseenter", v), D("mouseleave", d), D("mousemove", v)));
  }
  return w(
    je,
    {
      ...a,
      portal: true,
      className: "headlesui-float-cursor-root",
      onInitial: o
    }
  );
}
var yr = Object.assign(ct, { Reference: ir, Content: ur, Arrow: cr, Virtual: je, ContextMenu: sr, Cursor: lr });
export {
  yr as Float,
  Se as renderFloatingElement,
  it as renderReferenceElement,
  er as tailwindcssOriginClassResolver,
  gr as tailwindcssOriginSafelist,
  ar as useOutsideClick
};
/*! Bundled license information:

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.1.2
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

@headlessui-float/react/dist/headlessui-float.mjs:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@headlessui-float_react.js.map
